---
layout: default
---

## const关键字 #

如果const位于* 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。

### 指向常量的指针： ###

const 类型 *指针名  或者 类型 const *指针名      (约束针对所指对象访问)

### 表示常量： ##

const 类型 常量标识符= 常量表达式

### 指针常量： ##

指针常量说明指针的值只能在定义的时候初始化，定义后不能修改，不能改变指针的取向。但不影响所指向对象的访问特性。

类型 * const 指针名

### 指向常量的指针常量： ##

const 类型 * const指针名 或者 类型 const * const 指针名

### 常引用 ##

冠以const定义的引用，将约束对象用别名的方式访问的时候为只读。

const 类型 & 引用名 = 对象名

## 函数指针 ##

### 函数类型 ##

函数的类型是指函数的接口，包括函数的参数定义和返回值类型。

例如，以下是类型相同的函数：

	double p1(double,double);
	double p2(double,double);
	double p3(double,double);

c++中可以用typedef关键字定义函数类型名。函数类型名的一般形式为：

typedef 类型 函数类型名(形式参数表)

例如以上的三个函数的声明可以写成以下方式：

	typedef double functionType(double,double);
	functionType p1,p2,p3;


### 内联函数 ##

可以用于定义一些功能比较简单、代码比较短的函数。编译的时候，系统把内联函数的函数体嵌入到每个函数调用的地方，节省程序运行时的调用开销。

定义内联函数的方法，在函数名第一次出现的时候，在函数名之前冠以关键字inline。通常在函数原型中指出。若已在函数原型中指定inline，则函数定义的时候不能重复给出。

声明：

	incline 类型 函数名(形参列表)；

### 重载函数 ##

c++编译器只根据函数参数列表（参数的类型和个数）进行重载版本的调用匹配，函数返回值的内容不起作用，例如：

	int a(int, int);
	double a(int,int);

这两个不是重载函数，c++会认为函数重复说明。

##存储特性##

c++有两类存储特性：自动存储和静态存储。

c++把变量默认为自动存储，所以关键字auto很少用。

关键字register说明把变量存放在寄存器中。如今的c++编译器已经可以识别经常使用的变量，决定是否存放在寄存器中，而不需要程序员进行register说明。

关键字extern和static说明静态存储变量和函数标识符。全局说明的标识符默认为extern。

如果这两个关键字用于说明变量，程序再开始执行的时候就分配和初始化存储空间，如果用于说明函数，表示从程序执行开始就存在这个函数名。

用static声明的局部变量只能在定义该变量的函数体中使用。与自动变量不同的是，static在第一次使用的时候进行了初始化，函数退出时，系统保持其存储空间和数值，下次调用这个函数是，static变量还是上次退出函数时的值。

	#include<iostream>
	using namespace std;
	int func();
	int main() {
		cout << "a+b="<<func() << endl;
		cout << "a+b=" << func() << endl;
		system("pause");
	}

	int func() {
		int a = 0;
		static int b = 1;
		a++;
		b++;
		cout << "auto a=" << a << endl;
		cout << "static b=" << b << endl;
		return a + b;
	}

##宏定义指令##

###宏定义指令#define###
用来指定正文替换程序中出现的标识符。在c语言中不带参数的#define常用于定义常量，带参数的#define用于定义简单函数。

例如：

	#define PI 3.1415926535
	#define area(r) PI*r*r

由于宏指令是在程序正式编译之前执行的，所以不能对替换内容进行语法检查。c++的const关键字定义常量和inline定义内联函数代替了#define定义常量和函数的作用。

###条件编译###

条件编译指令可以根据一个常量值作为判断条件，决定源程序中某一段代码是否参加编译，条件编译指令的结构和if选择结构非常相似。以下是常见的形式：

若常量表达式的值为真（非0），则程序文本参与编译。

	#if 常量表达式
		程序文本
	#endif

若常量表达式为真（非0），则程序文本1参与编译，否则程序文本2参与编译。条件编译指令中的常量表达式必须在编译时（程序执行之前）就有确定值，不能再常量表达式中进行强制类型转换，或进行sizeof计算，也不能是枚举常量。

	#if 常量表达式
		程序文本1
	#else
		程序文本2
	#endif

若标识符没有定义，则程序文本被编译，若标识符已经定义，则程序文本被忽略。

	#ifndef 标识符
		#define 标识符
			程序文本
		#endif

##命名空间##
命名空间可以帮助程序员在开发新的软件组件的时候不会与已有的软件组件产生命名冲突。命名空间是类、函数、对象、类型和其他名字生命的集合。std是c++标准的名空间。

###定义命名空间###

开发一个应用程序常常需要多个库，它们源自不同的文件，这些文件常常用include进来。方便在其他文件调用。
定义命名空间如下：

	namespace 标识符
	{语句序列}

这样就可以用using语句

	using namespace 标识符;

将命名空间的元素纳入进来。

	标识符::函数名/对象名

并可以使用如上的方法来对命名空间的类、函数等等进行调用。

##预处理器指示符

（update Oct,11 2018）

	#include 指示符读入指定文件的内容 它有两种格式
	#include <some_file.h> 
	#include "my_file.h" 
 如果文件名用尖括号 < 和 > 括起来 表明这个文件是一个工程或标准头文件查找过程会检查预定义的目录我们可以通过设置搜索路径环境变量或命令行选项来修改这些目录。在不同的平台上这些方法大不相同 建议你请教同事或查阅编译器手册以获得更进一步的信息。如果文件名用一对引号括起来则表明该文件是用户提供的头文件查找该文件时将从当前文件目录开始。

![](https://i.imgur.com/SbD49VN.png)

![](https://i.imgur.com/bID8hzQ.png)


