---
layout: default
---

## const关键字 #

如果const位于* 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。

### 指向常量的指针： ###

const 类型 *指针名  或者 类型 const *指针名      (约束针对所指对象访问)

### 表示常量： ##

const 类型 常量标识符= 常量表达式

### 指针常量： ##

指针常量说明指针的值只能在定义的时候初始化，定义后不能修改，不能改变指针的取向。但不影响所指向对象的访问特性。

类型 * const 指针名

### 指向常量的指针常量： ##

const 类型 * const指针名 或者 类型 const * const 指针名

### 常引用 ##

冠以const定义的引用，将约束对象用别名的方式访问的时候为只读。

const 类型 & 引用名 = 对象名

## 函数指针 ##

### 函数类型 ##

函数的类型是指函数的接口，包括函数的参数定义和返回值类型。

例如，以下是类型相同的函数：

	double p1(double,double);
	double p2(double,double);
	double p3(double,double);

c++中可以用typedef关键字定义函数类型名。函数类型名的一般形式为：

typedef 类型 函数类型名(形式参数表)

例如以上的三个函数的声明可以写成以下方式：

	typedef double functionType(double,double);
	functionType p1,p2,p3;


### 内联函数 ##

可以用于定义一些功能比较简单、代码比较短的函数。编译的时候，系统把内联函数的函数体嵌入到每个函数调用的地方，节省程序运行时的调用开销。

定义内联函数的方法，在函数名第一次出现的时候，在函数名之前冠以关键字inline。通常在函数原型中指出。若已在函数原型中指定inline，则函数定义的时候不能重复给出。

特征：

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch 等复杂操作；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

声明：

	incline 类型 函数名(形参列表)；

编译器对 inline 函数的处理步骤：

1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

优点


1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器

### 重载函数 ##

c++编译器只根据函数参数列表（参数的类型和个数）进行重载版本的调用匹配，函数返回值的内容不起作用，例如：

	int a(int, int);
	double a(int,int);

这两个不是重载函数，c++会认为函数重复说明。

##存储特性##

c++有两类存储特性：自动存储和静态存储。

c++把变量默认为自动存储，所以关键字auto很少用。

关键字register说明把变量存放在寄存器中。如今的c++编译器已经可以识别经常使用的变量，决定是否存放在寄存器中，而不需要程序员进行register说明。

关键字extern和static说明静态存储变量和函数标识符。全局说明的标识符默认为extern。

如果这两个关键字用于说明变量，程序再开始执行的时候就分配和初始化存储空间，如果用于说明函数，表示从程序执行开始就存在这个函数名。

用static声明的局部变量只能在定义该变量的函数体中使用。与自动变量不同的是，static在第一次使用的时候进行了初始化，函数退出时，系统保持其存储空间和数值，下次调用这个函数是，static变量还是上次退出函数时的值。

	#include<iostream>
	using namespace std;
	int func();
	int main() {
		cout << "a+b="<<func() << endl;
		cout << "a+b=" << func() << endl;
		system("pause");
	}

	int func() {
		int a = 0;
		static int b = 1;
		a++;
		b++;
		cout << "auto a=" << a << endl;
		cout << "static b=" << b << endl;
		return a + b;
	}

##宏定义指令##

###宏定义指令#define###
用来指定正文替换程序中出现的标识符。在c语言中不带参数的#define常用于定义常量，带参数的#define用于定义简单函数。

例如：

	#define PI 3.1415926535
	#define area(r) PI*r*r

由于宏指令是在程序正式编译之前执行的，所以不能对替换内容进行语法检查。c++的const关键字定义常量和inline定义内联函数代替了#define定义常量和函数的作用。

###条件编译###

条件编译指令可以根据一个常量值作为判断条件，决定源程序中某一段代码是否参加编译，条件编译指令的结构和if选择结构非常相似。以下是常见的形式：

若常量表达式的值为真（非0），则程序文本参与编译。

	#if 常量表达式
		程序文本
	#endif

若常量表达式为真（非0），则程序文本1参与编译，否则程序文本2参与编译。条件编译指令中的常量表达式必须在编译时（程序执行之前）就有确定值，不能再常量表达式中进行强制类型转换，或进行sizeof计算，也不能是枚举常量。

	#if 常量表达式
		程序文本1
	#else
		程序文本2
	#endif

若标识符没有定义，则程序文本被编译，若标识符已经定义，则程序文本被忽略。

	#ifndef 标识符
		#define 标识符
			程序文本
		#endif

##命名空间##
命名空间可以帮助程序员在开发新的软件组件的时候不会与已有的软件组件产生命名冲突。命名空间是类、函数、对象、类型和其他名字生命的集合。std是c++标准的名空间。

###定义命名空间###

开发一个应用程序常常需要多个库，它们源自不同的文件，这些文件常常用include进来。方便在其他文件调用。
定义命名空间如下：

	namespace 标识符
	{语句序列}

这样就可以用using语句

	using namespace 标识符;

将命名空间的元素纳入进来。

	标识符::函数名/对象名

并可以使用如上的方法来对命名空间的类、函数等等进行调用。

##预处理器指示符

（update Oct,11 2018）

	#include 指示符读入指定文件的内容 它有两种格式
	#include <some_file.h> 
	#include "my_file.h" 
 如果文件名用尖括号 < 和 > 括起来 表明这个文件是一个工程或标准头文件查找过程会检查预定义的目录我们可以通过设置搜索路径环境变量或命令行选项来修改这些目录。在不同的平台上这些方法大不相同 建议你请教同事或查阅编译器手册以获得更进一步的信息。如果文件名用一对引号括起来则表明该文件是用户提供的头文件查找该文件时将从当前文件目录开始。

![](https://i.imgur.com/SbD49VN.png)

![](https://i.imgur.com/bID8hzQ.png)

##虚函数与动态绑定

一个虚函数在基类中被声明为virtual，则编译器将建立一个可由运行环境解释的特殊结构，并由程序执行时而不是编译时由运行环境来执行这个函数的调用。

若虚函数如下定义：
	
	virtual void draw()=0;

则这个函数被称为纯虚函数，如果一个类至少有一个纯虚函数，则该类是抽象类。一个抽象类必须作为基类被其他类集成，抽象类不能自己生成实例。继承抽象类的派生类必须自行定义自己的纯虚函数的实现。

### pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐。其实之所以有内存字节对齐机制，就是为了最大限度的减少内存读取次数。我们知道CPU读取速度比内存读取速度快至少一个数量级，所以为了节省运算花费时间，只能以牺牲空间来换取时间了。

	#pragma pack(push)  // 保存对齐状态
	#pragma pack(4)     // 设定为 4 字节对齐
	
	struct test
	{
	    char m1;
	    double m4;
	    int m3;
	};
	
	#pragma pack(pop)   // 恢复对齐状态

下面分析其存储情况，首先为 m1 分配空间，其偏移量 为 0，满足我们自己设定的对齐方式（4 字节对齐），m1 大小为 1 个字节。接着开始 为 m4 分配空间，这时其偏移量为 1，需要补足 3 个字节，这样使偏移量满足为 n=4 的倍数（因为 sizeof(double)大于 4）,m4 占用 8 个字节。接着为 m3 分配空间，这时 其偏移量为 12，满足为 4 的倍数，m3 占用 4 个字节。这时已经为所有成员变量分配 了空间，共分配了 16 个字节，满足为 n 的倍数。如果把上面的#pragma pack(4)改为 #pragma pack(8)，那么我们可以得到结构的大小为 24。

### volatile
	volatile int i = 10; 


- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

### extern "C"


- 被 extern 限定的函数或变量是 extern 类型的
- 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的

extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

example:

	#ifdef __cplusplus
	extern "C" {
	#endif
	
	void *memset(void *, int, size_t);
	
	#ifdef __cplusplus
	}
	#endif

###  struct 和 typedef struct

### C 中

	// c
	typedef struct Student {
	    int age; 
	} S;

等价于

	// c
	struct Student { 
	    int age; 
	};
	
	typedef struct Student S;

此时 S 等价于 struct Student，但两个标识符名称空间不相同。

另外还可以定义与 struct Student 不冲突的 void Student() {}。

### C++ 中

由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。

一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。

即表现为可以使用 Student 也可以使用 struct Student，如下：

	// cpp
	struct Student { 
	    int age; 
	};
	
	void f( Student me );       // 正确，"struct" 关键字可省略

二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：
	
	typedef struct Student { 
	    int age; 
	} S;
	
	void Student() {}           // 正确，定义后 "Student" 只代表此函数
	
	//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名
	
	int main() {
	    Student(); 
	    struct Student me;      // 或者 "S me";
	    return 0;
	}

## C++ 中 struct 和 class

总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

### 区别

最本质的一个区别就是默认的访问控制。

- 默认的继承访问权限。struct 是 public 的，class 是 private 的。

- struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

### explicit（显式）关键字



- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外


	struct A
	{
		A(int) { }
		operator bool() const { return true; }
	};
	
	struct B
	{
		explicit B(int) {}
		explicit operator bool() const { return true; }
	};
	
	void doA(A a) {}
	
	void doB(B b) {}
	
	int main()
	{
		A a1(1);		// OK：直接初始化
		A a2 = 1;		// OK：复制初始化
		A a3{ 1 };		// OK：直接列表初始化
		A a4 = { 1 };		// OK：复制列表初始化
		A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
		doA(1);			// OK：允许从 int 到 A 的隐式转换
		if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
		bool a6（a1）;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
		bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
		bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化
	
		B b1(1);		// OK：直接初始化
		B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
		B b3{ 1 };		// OK：直接列表初始化
		B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
		B b5 = (B)1;		// OK：允许 static_cast 的显式转换
		doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
		if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
		bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
		bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
		bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
	
		return 0;
	}

### friend 友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

### :: 范围解析运算符

#### 分类

1. 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
2. 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
3. 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的


	int count = 0;        // 全局（::）的 count
	class A {
	public:
	    static int count; // 类 A 的 count（A::count）
	};	
	int main() {
	    ::count = 1;      // 设置全局的 count 的值为 1
	
	    A::count = 2;     // 设置类 A 的 count 为 2
	
	    int count = 0;    // 局部的 count
	    count = 3;        // 设置局部的 count 的值为 3
	
	    return 0;
	}


